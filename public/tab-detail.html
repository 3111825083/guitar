<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>吉他谱详情 - 吉他谱网</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#E63946',
                        secondary: '#457B9D',
                        light: '#F1FAEE',
                        dark: '#1D3557',
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .btn-action {
                @apply px-3 py-1.5 rounded-lg transition-colors duration-300 flex items-center gap-1.5 text-sm;
            }
            .tab-fullscreen {
                @apply fixed top-0 left-0 right-0 bottom-0 z-50 bg-white flex flex-col p-4 overflow-auto;
            }
            .tab-fullscreen .tab-content {
                @apply w-full !max-w-none;
            }
            .tab-fullscreen img {
                @apply w-full h-auto !max-w-none rounded-lg shadow-md transition-shadow hover:shadow-lg;
            }
            .tab-content img {
                @apply max-w-3xl w-full rounded-lg shadow-md transition-shadow hover:shadow-lg;
            }
            .fullscreen-close {
                @apply absolute top-4 right-4 bg-primary text-white p-2 rounded-full cursor-pointer hover:bg-red-600 z-10;
            }
            .fullscreen-controls {
                @apply fixed top-4 left-4 bg-white border border-gray-200 rounded-lg shadow-lg p-2 z-[100] pointer-events-auto;
            }
            .fullscreen-controls .flex {
                @apply flex items-center gap-1.5 flex-wrap;
            }
        }

        /* 全局美化样式 */
        body {
            @apply bg-light/80;
        }
        header {
            @apply shadow-md;
        }
        #tabTitle {
            @apply text-2xl md:text-3xl text-dark/90;
        }
        #tabStats span {
            @apply text-gray-600;
        }
        .tab-content img {
            /* 样式已移到 @layer utilities 中 */
        }
        input[type="range"], select, input[type="number"] {
            @apply rounded-md border-gray-300 focus:outline-none focus:ring-1 focus:ring-primary focus:border-primary;
        }
        .relatedTabs .grid {
            @apply gap-4 md:gap-6;
        }
    </style>
</head>
<body class="bg-light text-dark min-h-screen" style="display: flex; flex-direction: column;">
    <header class="bg-white shadow-md z-50 flex-shrink-0" style="position: fixed; top: 0; left: 0; right: 0; width: 100%; height: 164px; z-index: 50;">
        <div class="container mx-auto px-4 flex justify-between items-center flex-wrap gap-1" style="height: 100%;">
            <a href="index.html" class="text-2xl font-bold text-primary">
                <i class="fas fa-guitar mr-2"></i>吉他谱网
            </a>

            <!-- 优化后的导航栏按钮组 -->
            <div class="flex flex-wrap gap-2 items-center">
                <button id="fullscreenBtn" class="btn-action bg-dark text-white hover:bg-gray-800 text-sm">
                    <i class="fas fa-expand"></i>
                    <span class="hidden sm:inline">全屏查看</span>
                </button>
                <button id="autoScrollBtn" class="btn-action border border-primary text-primary hover:bg-primary/10 text-sm" title="自动滚动">
                    <i class="fas fa-play"></i>
                    <span class="hidden sm:inline">自动滚动</span>
                </button>
                <div id="headerScrollControls" class="flex items-center gap-1">
                    <select id="scrollMode_hdr" class="hidden md:inline-block px-2 py-1 border border-gray-300 rounded text-xs" title="滚动模式">
                        <option value="custom">自定义</option>
                        <option value="uniform">匀速</option>
                    </select>
                    <div id="uniformSpeed_hdr" class="hidden md:inline-flex items-center gap-1">
                        <input type="range" id="scrollSpeed_hdr" min="50" max="500" value="100" step="10" class="h-1 w-20">
                        <span id="speedDisplay_hdr" class="text-xs text-gray-500 whitespace-nowrap">100px/s</span>
                    </div>
                </div>
                <button id="recordTimestampBtn" class="btn-action border border-blue-500 text-blue-600 hover:bg-blue-50 text-sm" title="录制时间戳">
                    <i class="fas fa-crosshairs"></i>
                    <span class="hidden sm:inline">录制</span>
                </button>
                <button id="submitRecordingBtn" class="hidden btn-action bg-green-500 text-white hover:bg-green-600 text-sm" title="提交时间戳">
                    <i class="fas fa-check"></i>
                    <span class="hidden sm:inline">提交</span>
                </button>
                <button id="cancelRecordingBtn" class="hidden btn-action bg-red-500 text-white hover:bg-red-600 text-sm" title="取消录制">
                    <i class="fas fa-times"></i>
                    <span class="hidden sm:inline">取消</span>
                </button>
                <button id="downloadBtn" class="btn-action bg-secondary text-white hover:bg-secondary/90 text-sm">
                    <i class="fas fa-download"></i>
                    <span class="hidden sm:inline">下载</span>
                </button>
                <button id="printBtn" class="btn-action border border-primary text-primary hover:bg-primary/10 text-sm" title="打印谱子">
                    <i class="fas fa-print"></i>
                    <span class="hidden sm:inline">打印</span>
                </button>
                <a href="index.html" class="btn-action bg-gray-200 hover:bg-gray-300 text-sm">
                    <i class="fas fa-arrow-left"></i>
                    <span class="hidden sm:inline">返回</span>
                </a>
            </div>
        </div>
    </header>

    <div style="flex: 1; margin-top: 164px;">
    <main class="container mx-auto px-4 py-8">
        <div class="bg-white rounded-xl shadow-md p-6 mb-8">
            <h1 id="tabTitle" class="text-3xl font-bold mb-2">加载中...</h1>
            <div class="flex flex-wrap gap-4 text-gray-500 mb-4" id="tabStats">
                <span id="singerSpan"><i class="fas fa-user mr-1"></i> 加载中...</span>
                <span id="typeSpan"><i class="fas fa-guitar mr-1"></i> 加载中...</span>
                <span id="viewSpan"><i class="fas fa-eye mr-1"></i> 加载中...</span>
                <span id="downloadSpan"><i class="fas fa-download mr-1"></i> 加载中...</span>
            </div>
            <p class="text-gray-600">调式：C调 | 难度：入门 | 拍号：4/4 | 速度：80BPM</p>
        </div>

        <!-- 美化后的谱子正文区域 -->
        <div class="bg-white rounded-xl shadow-md p-4 md:p-6 mb-8 transition-shadow hover:shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-center text-dark/80">吉他谱正文</h2>
            <div id="tabContent" class="tab-content space-y-4 md:space-y-6 flex flex-col items-center">
                <div class="text-center text-gray-500 py-8" id="loadingTip">
                    <i class="fas fa-spinner fa-spin mr-2"></i>正在加载谱子图片...
                </div>
            </div>
        </div>

        <div class="relatedTabs">
            <h2 class="text-2xl font-bold mb-6 text-dark/80">相关吉他谱推荐</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6" id="relatedTabs">
                <!-- 动态生成相关谱子 -->
            </div>
        </div>
    </main>

    <footer class="bg-dark text-white py-6 mt-12">
        <div class="container mx-auto px-4 text-center">
            <p class="mb-2">© 2025 吉他谱网 - 免费分享吉他谱资源</p>
            <p class="text-sm text-gray-400">本站谱子仅供学习交流，禁止商用</p>
        </div>
    </footer>
    </div>

    <script>
        // 全局变量：谱子配置数据
        let tabsConfig = {};
        let currentTabKey = null;
        let currentTab = null;
        // 从URL获取参数
        const urlParams = new URLSearchParams(window.location.search);
        const tabId = urlParams.get('id');
        const tabName = decodeURIComponent(urlParams.get('name') || '未知谱子');
        const tabFolder = decodeURIComponent(urlParams.get('folder') || tabName);

        // API 基础地址（自适应环境）
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000/api'
            : `${window.location.protocol}//${window.location.host}/api`;

        // 1. 加载配置文件，获取谱子详细信息
        async function loadTabConfig() {
            try {
                const response = await fetch(`${API_BASE}/tabs`);
                if (!response.ok) throw new Error('配置文件加载失败');
                tabsConfig = await response.json();
                // 从配置中找到当前谱子的信息（通过ID匹配）
                currentTabKey = Object.keys(tabsConfig).find(folder => tabsConfig[folder].id === tabId);
                currentTab = currentTabKey ? tabsConfig[currentTabKey] : null;

                if (!currentTab) {
                    throw new Error('未找到该谱子的配置信息');
                }

                // 更新页面标题和谱子标题
                document.title = `${tabName} - 吉他谱详情 - 吉他谱网`;
                document.getElementById('tabTitle').textContent = `${tabName} - ${currentTab.singer}`;
                // 更新统计信息
                document.getElementById('singerSpan').innerHTML = `<i class="fas fa-user mr-1"></i> ${currentTab.singer}`;
                document.getElementById('typeSpan').innerHTML = `<i class="fas fa-guitar mr-1"></i> ${currentTab.type}谱`;
                document.getElementById('viewSpan').innerHTML = `<i class="fas fa-eye mr-1"></i> ${currentTab.view}次浏览`;
                document.getElementById('downloadSpan').innerHTML = `<i class="fas fa-download mr-1"></i> ${currentTab.download}次下载`;

                // 生成相关谱子推荐
                generateRelatedTabs(currentTabKey);
                // 准备自动滚动参数（确保存在数组）
                if (currentTab && !Array.isArray(currentTab.scroll)) currentTab.scroll = [{time:0, position:0}];
            } catch (error) {
                document.getElementById('tabTitle').textContent = '加载失败';
                document.getElementById('tabStats').innerHTML = `<span class="text-red-500">${error.message}</span>`;
                console.error('加载谱子配置失败：', error);
            }
        }

        // 2. 生成相关谱子推荐（排除当前谱子）
        function generateRelatedTabs(currentFolder) {
            const relatedTabs = document.getElementById('relatedTabs');
            // 取前3个非当前谱子的项作为推荐
            const otherTabs = Object.keys(tabsConfig).filter(folder => folder !== currentFolder).slice(0, 3);
            otherTabs.forEach(folderName => {
                const tab = tabsConfig[folderName];
                const relatedItem = document.createElement('div');
                relatedItem.className = 'bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow duration-300 cursor-pointer';
                relatedItem.onclick = () => {
                    window.location.href = `tab-detail.html?id=${tab.id}&name=${encodeURIComponent(folderName)}&folder=${encodeURIComponent(folderName)}`;
                };
                // 美化后的相关谱子卡片
                relatedItem.innerHTML = `
                    <h3 class="text-lg font-semibold mb-1 text-dark/80">${folderName}</h3>
                    <p class="text-gray-500 text-xs mb-3">${tab.singer} | ${tab.type}谱</p>
                    <img src="${tab.cover}" alt="${folderName}吉他谱封面" class="w-full h-32 object-cover rounded-lg shadow-sm transition-transform hover:scale-[1.02]">
                `;
                relatedTabs.appendChild(relatedItem);
            });
        }

        // 3. 动态加载谱子图片（原有逻辑不变）
        const tabContent = document.getElementById('tabContent');
        const loadingTip = document.getElementById('loadingTip');
        const maxPage = 5;

        function checkImageExists(url, callback) {
            const img = new Image();
            img.onload = () => callback(true);
            img.onerror = () => callback(false);
            img.src = url;
        }

        function loadTabImages() {
            let page = 1;
            loadingTip.textContent = '正在加载谱子图片...';

            function loadNextPage() {
                const imgUrl = `./source/${tabFolder}/${page}.png`;
                checkImageExists(imgUrl, (exists) => {
                    if (exists) {
                        const img = document.createElement('img');
                        img.src = imgUrl;
                        img.alt = `${tabName}吉他谱第${page}页`;
                        img.className = 'w-full max-w-3xl mx-auto rounded-md shadow-sm';
                        tabContent.appendChild(img);
                        page++;
                        loadNextPage();
                    } else {
                        loadingTip.remove();
                        if (page === 1) {
                            const emptyTip = document.createElement('p');
                            emptyTip.className = 'text-center text-red-500';
                            emptyTip.textContent = `未找到《${tabName}》的png格式谱子图片，请检查文件夹是否存在或图片命名是否正确！`;
                            tabContent.appendChild(emptyTip);
                        }
                        // 标记图片已加载完（无论是否找到图片），并触发后续步骤生成
                        imagesLoaded = true;
                        try { onImagesLoaded(); } catch (e) { /* ignore */ }
                    }
                });
            }
            loadNextPage();
        }

        // 当图片加载完成后，尝试基于图片位置生成滚动 steps（如果配置未提供）
        function onImagesLoaded() {
            // 选择测量根：全屏优先，否则页面内 tabContent
            const measureRoot = (isFullscreen && fullscreenContainer) ? fullscreenContainer : tabContent;
            const imgs = measureRoot ? Array.from(measureRoot.querySelectorAll('img')) : [];
            const cfgSteps = (currentTab && Array.isArray(currentTab.scroll)) ? currentTab.scroll.slice() : [];
            const needAutoGenerate = (cfgSteps.length === 1 && cfgSteps[0].time === 0 && cfgSteps[0].position === 0);

            if (!needAutoGenerate) return;
            if (!imgs.length) return;

            const generated = imgs.map((img, idx) => {
                let pos = img.offsetTop || 0;
                pos = Math.round(pos);
                return { time: idx * 5, position: pos };
            });
            // 补充最终位置（页底）
            const target = (isFullscreen && fullscreenContainer) ? fullscreenContainer : document.scrollingElement || document.documentElement;
            const maxScroll = (target && typeof target.scrollHeight === 'number' && typeof target.clientHeight === 'number') ? Math.max(0, target.scrollHeight - target.clientHeight) : null;
            if (maxScroll !== null && generated.length) {
                const last = generated[generated.length - 1];
                if (Math.abs(last.position - maxScroll) > 20) {
                    generated.push({ time: generated[generated.length - 1].time + 5, position: Math.round(maxScroll) });
                }
            }
            autoScrollState.steps = generated;

            // 如果之前等待图片加载再开始滚动，则启动
            if (autoScrollState.waitingForImages) {
                autoScrollState.waitingForImages = false;
                startAutoScroll();
            }
        }

        // 4. 下载和打印功能（原有逻辑不变）
        document.getElementById('downloadBtn').addEventListener('click', () => {
            alert(`开始下载《${tabName}》的所有谱子图片！\n实际项目中可使用JSZip打包文件夹内的图片后下载`);
        });

        document.getElementById('printBtn').addEventListener('click', () => {
            window.print();
        });

        if (window.matchMedia) {
            const mediaQuery = window.matchMedia('print');
            mediaQuery.addEventListener('change', (e) => {
                if (e.matches) {
                    document.querySelector('header').style.display = 'none';
                    document.querySelector('footer').style.display = 'none';
                    document.querySelector('#relatedTabs').style.display = 'none';
                } else {
                    document.querySelector('header').style.display = 'block';
                    document.querySelector('footer').style.display = 'block';
                    document.querySelector('#relatedTabs').style.display = 'grid';
                }
            });
        }
        // ========== 新增：全屏查看逻辑 ==========
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const tabContentParent = tabContent.parentElement; // 谱子容器的父元素
        let isFullscreen = false; // 全屏状态标记
        let fullscreenContainer = null; // 全屏容器

        // 创建全屏容器并切换状态
        fullscreenBtn.addEventListener('click', () => {
            if (!isFullscreen) {
                // 进入全屏：创建全屏容器，复制谱子内容到其中
                fullscreenContainer = document.createElement('div');
                fullscreenContainer.className = 'tab-fullscreen';
                fullscreenContainer.style.overflow = 'auto';
                fullscreenContainer.style.paddingTop = '80px'; // 为悬浮按钮预留空间
                
                // 复制谱子内容（深拷贝，保留图片）
                fullscreenContainer.appendChild(tabContent.cloneNode(true));
                
                // 创建固定悬浮的控制面板（不是 fullscreenContainer 的子元素）
                const fsControl = document.createElement('div');
                fsControl.id = 'fullscreenControlPanel';
                fsControl.className = 'fullscreen-controls';
                
                // 美化后的全屏控制面板
                fsControl.innerHTML = `
                    <div class="flex items-center gap-1.5 flex-wrap">
                        <button id="autoScrollBtn_fs" class="btn-action border border-primary text-primary hover:bg-primary/10 text-sm"><i class="fas fa-play"></i><span class="hidden sm:inline">自动滚动</span></button>
                        <button id="recordTimestampBtn_fs" class="btn-action border border-blue-500 text-blue-600 hover:bg-blue-50 text-sm" title="录制时间戳"><i class="fas fa-crosshairs"></i><span class="hidden sm:inline">录制</span></button>
                        <button id="submitRecordingBtn_fs" class="hidden btn-action bg-green-500 text-white hover:bg-green-600 text-sm" title="提交时间戳"><i class="fas fa-check"></i><span class="hidden sm:inline">提交</span></button>
                        <button id="cancelRecordingBtn_fs" class="hidden btn-action bg-red-500 text-white hover:bg-red-600 text-sm" title="取消录制"><i class="fas fa-times"></i><span class="hidden sm:inline">取消</span></button>
                        <div id="recordingStatus_fs_display" class="text-xs text-blue-600 font-semibold hidden">已记录: <span id="recordingCount_fs">0</span> 个</div>
                        <button id="settingsToggle_fs" class="btn-action border border-gray-300 text-gray-600 text-sm" title="设置"><i class="fas fa-cog"></i></button>
                        <div id="settingsMenu_fs" class="hidden absolute mt-10 left-0 bg-white border border-gray-300 rounded-lg shadow-lg p-2 z-[110] w-52">
                            <div class="mb-2">
                                <label class="block text-xs font-semibold mb-1">滚动模式</label>
                                <select id="scrollMode_fs" class="w-full px-2 py-1 border border-gray-300 rounded text-xs">
                                    <option value="custom">自定义时间戳</option>
                                    <option value="uniform">匀速滚动</option>
                                </select>
                            </div>
                            <div id="uniformSpeedControl_fs" class="hidden">
                                <label class="block text-xs font-semibold mb-1">速度 (px/s)</label>
                                <input type="range" id="scrollSpeed_fs" min="50" max="500" value="100" step="10" class="w-full h-1.5">
                                <span id="speedDisplay_fs" class="text-xs text-gray-500">100 px/s</span>
                            </div>
                        </div>
                    </div>
                `;
                
                // 添加关闭按钮到全屏容器（固定位置）
                const closeBtn = document.createElement('button');
                closeBtn.className = 'fullscreen-close';
                closeBtn.innerHTML = '<i class="fas fa-times"></i>';
                closeBtn.onclick = () => toggleFullscreen(false);
                fullscreenContainer.appendChild(closeBtn);
                
                // 添加全屏容器到 body
                document.body.appendChild(fullscreenContainer);
                
                // 添加控制面板到 body（固定定位，不受滚动影响）
                document.body.appendChild(fsControl);
                
                // 禁止原页面滚动
                document.body.style.overflow = 'hidden';
                isFullscreen = true;
                // 绑定全屏下的模式和速度控件事件
                bindFullscreenControls();
                // 进入全屏后根据全屏容器内的图片重新生成 steps（如果需要）
                prepareSteps();
                // 按钮文字切换
                fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i><span class="hidden sm:inline">退出全屏</span>';
                // 进入全屏时启用自动滚动按钮
                autoScrollBtn.disabled = false;
                autoScrollBtn.style.opacity = '1';
                autoScrollBtn.style.cursor = 'pointer';
            } else {
                // 退出全屏
                toggleFullscreen(false);
            }
        });

        // 退出全屏的通用方法
        function toggleFullscreen(flag = true) {
            if (fullscreenContainer) {
                fullscreenContainer.remove();
                fullscreenContainer = null;
            }
            // 移除固定的控制面板
            const fsControl = document.getElementById('fullscreenControlPanel');
            if (fsControl) {
                fsControl.remove();
            }
            document.body.style.overflow = '';
            isFullscreen = false;
            fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i><span class="hidden sm:inline">全屏查看</span>';
            // 退出全屏时禁用自动滚动按钮
            autoScrollBtn.disabled = true;
            autoScrollBtn.style.opacity = '0.5';
            autoScrollBtn.style.cursor = 'not-allowed';
            // exit fullscreen: ensure auto-scroll stopped
            stopAutoScrollOnExit();
        }

        // 按ESC键退出全屏
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                toggleFullscreen(false);
            }
        });
        // ========== 新增：自动滚动逻辑 ==========
        const autoScrollBtn = document.getElementById('autoScrollBtn');
        let imagesLoaded = false; // 标记图片是否已加载完
        
        let autoScrollState = {
            playing: false,
            rafId: null,
            startTime: 0,
            pausedAt: 0,
            steps: [],
            mode: 'custom', // 'custom' 或 'uniform'
            speed: 100 // 匀速模式下的速度 px/s
        };

        // 注意：滚动模式/速度的绑定将在全屏模式下由 bindFullscreenControls() 动态绑定

        function getScrollTarget() {
            // 如果在全屏模式，滚动目标是全屏容器，否则滚动页面主区域（tabContent 的父容器）
            if (isFullscreen && fullscreenContainer) return fullscreenContainer;
            return document.scrollingElement || document.documentElement;
        }

        function prepareSteps() {
            const steps = (currentTab && Array.isArray(currentTab.scroll)) ? currentTab.scroll.slice() : [];
            // 确保至少有起点
            if (steps.length === 0) steps.push({time:0, position:0});
            // 按时间排序
            steps.sort((a,b) => a.time - b.time);
            autoScrollState.steps = steps;
            // Debug: 输出计算得到的 steps，便于核对
            try { console.debug('prepareSteps -> mode:', autoScrollState.mode, 'steps:', JSON.parse(JSON.stringify(autoScrollState.steps))); } catch(e) {}
            
            // 如果配置里只有起点（比如很多谱子没有配置滚动），尝试从页面内容自动生成位置
            const needAutoGenerate = (steps.length === 1 && steps[0].time === 0 && steps[0].position === 0);
            if (needAutoGenerate) {
                // 如果图片尚未加载完，延后生成（onImagesLoaded 会处理）
                const measureRoot = (isFullscreen && fullscreenContainer) ? fullscreenContainer : tabContent;
                const imgs = measureRoot ? Array.from(measureRoot.querySelectorAll('img')) : [];
                if (imgs.length > 0) {
                    // 默认每页间隔（仅在 custom 模式下使用）
                    const interval = 5; // seconds per page (fallback)
                    const generated = imgs.map((img, idx) => {
                        let pos = img.offsetTop || 0;
                        pos = Math.round(pos);
                        return { time: idx * interval, position: pos };
                    });
                    // 补充最终最大滚动位置，避免停在最后一张图片顶部
                    const target = (isFullscreen && fullscreenContainer) ? fullscreenContainer : document.scrollingElement || document.documentElement;
                    const maxScroll = (target && typeof target.scrollHeight === 'number' && typeof target.clientHeight === 'number') ? Math.max(0, target.scrollHeight - target.clientHeight) : null;
                    if (maxScroll !== null && generated.length) {
                        const last = generated[generated.length - 1];
                        if (Math.abs(last.position - maxScroll) > 20) {
                            generated.push({ time: generated[generated.length - 1].time + interval, position: Math.round(maxScroll) });
                        }
                    }
                    autoScrollState.steps = generated;
                } else {
                    // 图片还没加载，等待 loadTabImages 完成后再生成
                    // onImagesLoaded 会在图片加载完成时调用 prepareSteps()
                }
            }

            // 计算总滚动高度和总时间（用于匀速模式）
            if (autoScrollState.mode === 'uniform') {
                const lastStep = autoScrollState.steps && autoScrollState.steps.length ? autoScrollState.steps[autoScrollState.steps.length - 1] : { position: 0 };
                autoScrollState.totalDuration = Math.max((lastStep.position || 0) / Math.max(1, autoScrollState.speed), 1);
            }
        }

        function tick(now) {
            if (!autoScrollState.playing) return;
            if (!autoScrollState.startTime) autoScrollState.startTime = now - (autoScrollState.pausedAt || 0);
            const elapsed = (now - autoScrollState.startTime) / 1000; // seconds
            const steps = autoScrollState.steps;
            const target = getScrollTarget();
            if (!steps.length) return;

            let pos = 0;

            if (autoScrollState.mode === 'custom') {
                // 自定义时间戳模式：按照步骤插值
                let i = 0;
                while (i < steps.length-1 && elapsed >= steps[i+1].time) i++;
                const s1 = steps[i];
                const s2 = (i < steps.length-1) ? steps[i+1] : null;
                pos = s1.position;
                if (s2) {
                    const dt = s2.time - s1.time;
                    const t = dt === 0 ? 0 : (elapsed - s1.time) / dt;
                    const clamped = Math.max(0, Math.min(1, t));
                    pos = s1.position + (s2.position - s1.position) * clamped;
                } else {
                    // after last step: continue moving using the last segment's speed
                    const last = s1;
                    const prev = (i > 0) ? steps[i-1] : null;
                    // 计算最后一段速度（px/s），若无前一段则使用 autoScrollState.speed 作为回退
                    let lastSpeed = autoScrollState.speed || 100;
                    if (prev) {
                        const dtp = last.time - prev.time;
                        if (dtp > 0) lastSpeed = (last.position - prev.position) / dtp;
                    }
                    const extra = Math.max(0, elapsed - last.time);
                    pos = last.position + lastSpeed * extra;
                    // 如果已知最大滚动位置，限制并在到达谱子末尾时停止
                    if (typeof autoScrollState.maxScroll === 'number') {
                        if (pos >= autoScrollState.maxScroll) {
                            pos = autoScrollState.maxScroll;
                            stopAutoScroll();
                        }
                    }
                }
            } else if (autoScrollState.mode === 'uniform') {
                // 匀速模式：以恒定速度滚动
                pos = autoScrollState.speed * elapsed;
                // 在匀速模式下，以谱子最大可滚动位置为终点（如果已计算），否则以最后步的位置为备选
                if (typeof autoScrollState.maxScroll === 'number') {
                    if (pos >= autoScrollState.maxScroll) {
                        pos = autoScrollState.maxScroll;
                        stopAutoScroll();
                    }
                } else {
                    const lastStep = steps[steps.length - 1];
                    if (lastStep && pos >= lastStep.position) {
                        pos = lastStep.position;
                        stopAutoScroll();
                    }
                }
            }

            // apply position
            try {
                target.scrollTop = pos;
            } catch (e) {
                // fallback: window scroll
                window.scrollTo(0, pos);
            }

            // Debug: 每秒记录一次位置和 elapsed，便于对比预期时间戳
            try {
                if (!tick._lastLogSec) tick._lastLogSec = -1;
                const sec = Math.floor(elapsed);
                if (sec !== tick._lastLogSec) {
                    tick._lastLogSec = sec;
                    console.debug('tick:', { elapsed: elapsed.toFixed(2), pos: Math.round(pos), targetScrollTop: (target && target.scrollTop), nextSteps: autoScrollState.steps && autoScrollState.steps.slice(0,5) });
                }
            } catch (e) {}

            autoScrollState.rafId = requestAnimationFrame(tick);
        }

        function startAutoScroll() {
            if (autoScrollState.playing) return;
            // 如果配置只有默认起点且图片尚未加载完，等待图片加载再开始
            const cfgSteps = (currentTab && Array.isArray(currentTab.scroll)) ? currentTab.scroll.slice() : [];
            const needAutoGenerate = (cfgSteps.length === 1 && cfgSteps[0].time === 0 && cfgSteps[0].position === 0);
            if (needAutoGenerate && !imagesLoaded) {
                autoScrollState.waitingForImages = true;
                return; // onImagesLoaded 会在图片加载后触发 startAutoScroll
            }
            prepareSteps();
            // 确定当前滚动目标和最大可滚动位置（以谱子容器为准）
            try {
                const target = getScrollTarget();
                autoScrollState.target = target;
                autoScrollState.maxScroll = (target && typeof target.scrollHeight === 'number' && typeof target.clientHeight === 'number') ? Math.max(0, target.scrollHeight - target.clientHeight) : null;
                // 将 steps 的 position 限制在最大滚动范围内，防止超出
                if (Array.isArray(autoScrollState.steps) && typeof autoScrollState.maxScroll === 'number') {
                    autoScrollState.steps = autoScrollState.steps.map(s => ({ time: s.time, position: Math.min(s.position, autoScrollState.maxScroll) }));
                }
            } catch (e) {
                // ignore
            }
            autoScrollState.playing = true;
            autoScrollState.startTime = 0;
            autoScrollState.pausedAt = 0;
            // update UI icons
            updateAutoScrollButtons(true);
            autoScrollState.rafId = requestAnimationFrame(tick);
        }

        function stopAutoScroll() {
            autoScrollState.playing = false;
            if (autoScrollState.rafId) cancelAnimationFrame(autoScrollState.rafId);
            autoScrollState.rafId = null;
            autoScrollState.startTime = 0;
            autoScrollState.pausedAt = 0;
            updateAutoScrollButtons(false);
        }

        function toggleAutoScroll() {
            if (autoScrollState.playing) {
                stopAutoScroll();
            } else {
                startAutoScroll();
            }
        }

        function updateAutoScrollButtons(isPlaying) {
            const icons = document.querySelectorAll('#autoScrollBtn i, #autoScrollBtn_fs i');
            icons.forEach(ic => {
                ic.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
            });
        }

        // wire up main header button and future fullscreen copy
        autoScrollBtn.addEventListener('click', () => {
            prepareSteps();
            toggleAutoScroll();
        });

        // 录制按钮（页头）绑定
        const recordHeaderBtn = document.getElementById('recordTimestampBtn');
        const submitHeaderBtn = document.getElementById('submitRecordingBtn');
        const cancelHeaderBtn = document.getElementById('cancelRecordingBtn');
        // Header scroll controls bindings
        const scrollModeHdr = document.getElementById('scrollMode_hdr');
        const scrollSpeedHdr = document.getElementById('scrollSpeed_hdr');
        const speedDisplayHdr = document.getElementById('speedDisplay_hdr');
        if (recordHeaderBtn) {
            recordHeaderBtn.addEventListener('click', (evt) => {
                evt.stopPropagation();
                toggleRecordingMode();
            });
        }
        if (submitHeaderBtn) {
            submitHeaderBtn.addEventListener('click', (evt) => {
                evt.stopPropagation();
                evt.preventDefault();
                submitRecording();
            });
        }
        if (cancelHeaderBtn) {
            cancelHeaderBtn.addEventListener('click', (evt) => {
                evt.stopPropagation();
                evt.preventDefault();
                cancelRecording();
            });
        }

        // header scroll mode change
        if (scrollModeHdr) {
            // show on larger screens
            scrollModeHdr.classList.remove('hidden');
            scrollModeHdr.value = autoScrollState.mode || 'custom';
            scrollModeHdr.addEventListener('change', (e) => {
                autoScrollState.mode = e.target.value;
                // show header speed control when uniform
                const speedWrap = document.getElementById('uniformSpeed_hdr');
                if (e.target.value === 'uniform') {
                    if (speedWrap) speedWrap.classList.remove('hidden');
                } else {
                    if (speedWrap) speedWrap.classList.add('hidden');
                }
                if (autoScrollState.playing) {
                    stopAutoScroll();
                    startAutoScroll();
                }
            });
        }
        if (scrollSpeedHdr) {
            scrollSpeedHdr.value = autoScrollState.speed || 100;
            if (speedDisplayHdr) speedDisplayHdr.textContent = `${autoScrollState.speed} px/s`;
            scrollSpeedHdr.addEventListener('input', (e) => {
                autoScrollState.speed = parseInt(e.target.value) || 100;
                if (speedDisplayHdr) speedDisplayHdr.textContent = `${autoScrollState.speed} px/s`;
                if (autoScrollState.playing) {
                    stopAutoScroll();
                    startAutoScroll();
                }
            });
        }

        // delegate clicks on potential fullscreen copy button
        document.addEventListener('click', (e) => {
            const fsBtn = e.target.closest('#autoScrollBtn_fs');
            if (fsBtn) {
                prepareSteps();
                toggleAutoScroll();
            }
        });

        // 录制时间戳的全局状态
        let recordingMode = {
            enabled: false,
            captures: [] // { position, timestamp }
        };

        // 在全屏下绑定模式/速度控件（动态绑定，因为全屏容器是运行时创建的）
        function bindFullscreenControls() {
            if (!fullscreenContainer) return;
            const fsAutoBtn = document.getElementById('autoScrollBtn_fs');
            const recordBtn = document.getElementById('recordTimestampBtn_fs');
            const settingsToggle = document.getElementById('settingsToggle_fs');
            const settingsMenu = document.getElementById('settingsMenu_fs');
            const scrollMode_fs = document.getElementById('scrollMode_fs');
            const scrollSpeed_fs = document.getElementById('scrollSpeed_fs');
            const speedDisplay_fs = document.getElementById('speedDisplay_fs');
            const uniformControl_fs = document.getElementById('uniformSpeedControl_fs');

            // 初始化显示值
            if (speedDisplay_fs) speedDisplay_fs.textContent = `${autoScrollState.speed} px/s`;
            if (scrollMode_fs) scrollMode_fs.value = autoScrollState.mode || 'custom';
            if (uniformControl_fs) {
                if (autoScrollState.mode === 'uniform') uniformControl_fs.classList.remove('hidden');
                else uniformControl_fs.classList.add('hidden');
            }

            // 自动滚动按钮（全屏）
            if (fsAutoBtn) {
                fsAutoBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    prepareSteps();
                    toggleAutoScroll();
                });
            }

            // 设置菜单切换
            if (settingsToggle && settingsMenu) {
                settingsToggle.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    settingsMenu.classList.toggle('hidden');
                });
            }

            // 点击全屏容器任意位置（非菜单和按钮）时关闭菜单
            if (fullscreenContainer) {
                fullscreenContainer.addEventListener('click', (evt) => {
                    if (!evt.target.closest('#settingsMenu_fs') && !evt.target.closest('#settingsToggle_fs')) {
                        if (settingsMenu) settingsMenu.classList.add('hidden');
                    }
                });
            }

            // 滚动模式切换（全屏）
            if (scrollMode_fs) {
                scrollMode_fs.addEventListener('change', (e) => {
                    autoScrollState.mode = e.target.value;
                    if (e.target.value === 'uniform') {
                        if (uniformControl_fs) uniformControl_fs.classList.remove('hidden');
                    } else {
                        if (uniformControl_fs) uniformControl_fs.classList.add('hidden');
                    }
                    if (autoScrollState.playing) {
                        stopAutoScroll();
                        startAutoScroll();
                    }
                });
            }

            // 速度调节（全屏）
            if (scrollSpeed_fs) {
                scrollSpeed_fs.addEventListener('input', (e) => {
                    autoScrollState.speed = parseInt(e.target.value) || 100;
                    if (speedDisplay_fs) speedDisplay_fs.textContent = `${autoScrollState.speed} px/s`;
                    if (autoScrollState.playing) {
                        stopAutoScroll();
                        startAutoScroll();
                    }
                });
            }

            // 录制时间戳按钮（全屏）
            if (recordBtn) {
                recordBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    toggleRecordingMode();
                });
            }
            
            // 提交按钮（全屏）
            const submitBtn = document.getElementById('submitRecordingBtn_fs');
            if (submitBtn) {
                submitBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();
                    submitRecording();
                });
            }
            
            // 取消按钮（全屏）
            const cancelBtn = document.getElementById('cancelRecordingBtn_fs');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();
                    cancelRecording();
                });
            }
        }

        // 切换录制模式
        function toggleRecordingMode() {
            recordingMode.enabled = !recordingMode.enabled;
            // 支持全屏与非全屏两套按钮
            const fsRecordBtn = document.getElementById('recordTimestampBtn_fs');
            const fsSubmitBtn = document.getElementById('submitRecordingBtn_fs');
            const fsCancelBtn = document.getElementById('cancelRecordingBtn_fs');
            const fsStatusDisplay = document.getElementById('recordingStatus_fs_display');
            const fsCountDisplay = document.getElementById('recordingCount_fs');

            const hdrRecordBtn = document.getElementById('recordTimestampBtn');
            const hdrSubmitBtn = document.getElementById('submitRecordingBtn');
            const hdrCancelBtn = document.getElementById('cancelRecordingBtn');
            const hdrCountDisplay = document.getElementById('recordingCount');

            // helper to show/hide submit & cancel
            function showSubmitCancel(show) {
                if (fsSubmitBtn) show ? fsSubmitBtn.classList.remove('hidden') : fsSubmitBtn.classList.add('hidden');
                if (fsCancelBtn) show ? fsCancelBtn.classList.remove('hidden') : fsCancelBtn.classList.add('hidden');
                if (hdrSubmitBtn) show ? hdrSubmitBtn.classList.remove('hidden') : hdrSubmitBtn.classList.add('hidden');
                if (hdrCancelBtn) show ? hdrCancelBtn.classList.remove('hidden') : hdrCancelBtn.classList.add('hidden');
            }

            if (recordingMode.enabled) {
                // 进入录制模式
                recordingMode.captures = [];
                if (fsRecordBtn) {
                    fsRecordBtn.style.backgroundColor = '#93c5fd';
                    fsRecordBtn.style.color = '#1e40af';
                    fsRecordBtn.textContent = '⏹ 停止录制';
                }
                if (hdrRecordBtn) {
                    hdrRecordBtn.style.backgroundColor = '#93c5fd';
                    hdrRecordBtn.style.color = '#1e40af';
                    hdrRecordBtn.textContent = '⏹ 停止录制';
                }

                // 显示提交和取消按钮
                showSubmitCancel(true);
                if (fsStatusDisplay) fsStatusDisplay.classList.remove('hidden');
                if (fsCountDisplay) fsCountDisplay.textContent = '0';

                // 设置光标并绑定点击事件到正确容器
                if (isFullscreen && fullscreenContainer) {
                    fullscreenContainer.style.cursor = 'crosshair';
                    fullscreenContainer.addEventListener('click', capturePosition, true);
                } else {
                    // 非全屏：在主内容区域捕获点击（tabContent）
                    if (tabContent) {
                        tabContent.style.cursor = 'crosshair';
                        tabContent.addEventListener('click', capturePosition, true);
                    }
                }
            } else {
                // 退出录制模式
                if (fsRecordBtn) {
                    fsRecordBtn.style.backgroundColor = '';
                    fsRecordBtn.style.color = '';
                    fsRecordBtn.innerHTML = '<i class="fas fa-crosshairs"></i><span class="hidden sm:inline">录制</span>';
                }
                if (hdrRecordBtn) {
                    hdrRecordBtn.style.backgroundColor = '';
                    hdrRecordBtn.style.color = '';
                    hdrRecordBtn.innerHTML = '<i class="fas fa-crosshairs"></i><span class="hidden sm:inline">录制</span>';
                }

                // 隐藏提交和取消按钮
                showSubmitCancel(false);
                if (fsStatusDisplay) fsStatusDisplay.classList.add('hidden');

                // 移除事件监听
                try {
                    if (isFullscreen && fullscreenContainer) {
                        fullscreenContainer.style.cursor = 'auto';
                        fullscreenContainer.removeEventListener('click', capturePosition, true);
                    }
                } catch (e) {}
                try {
                    if (tabContent) {
                        tabContent.style.cursor = 'auto';
                        tabContent.removeEventListener('click', capturePosition, true);
                    }
                } catch (e) {}

                // 如果有记录的时间戳，显示确认对话框
                if (recordingMode.captures.length > 0) {
                    showRecordingSummary();
                }
            }
        }

        // 取消录制
        function cancelRecording() {
            recordingMode.captures = [];
            recordingMode.enabled = true; // 因为 toggleRecordingMode 会翻转它
            toggleRecordingMode();
            alert('已取消录制');
        }

        // 手动提交录制结果
        function submitRecording() {
            if (recordingMode.captures.length === 0) {
                alert('还没有记录任何时间戳！');
                return;
            }
            
            // 停止录制模式
            recordingMode.enabled = true; // 因为 toggleRecordingMode 会翻转它
            toggleRecordingMode();
            
            // 显示确认对话框
            showRecordingSummary();
        }

        // 捕捉点击位置
        function capturePosition(evt) {
            if (!recordingMode.enabled) return;

            // 如果点击的是控制面板中的按钮或其他元素，忽略（检查全屏和页头面板）
            const fsControl = document.getElementById('fullscreenControlPanel');
            if (fsControl && fsControl.contains(evt.target)) return;
            const hdrControl = document.getElementById('recordTimestampBtn');
            if (hdrControl && hdrControl.contains(evt.target)) return;

            evt.stopPropagation();
            evt.preventDefault();

            let position = 0;
            if (isFullscreen && fullscreenContainer) {
                // 计算相对于全屏容器的点击位置
                const rect = fullscreenContainer.getBoundingClientRect();
                const relativeY = evt.clientY - rect.top + fullscreenContainer.scrollTop;
                position = Math.round(relativeY);
            } else {
                // 非全屏：计算相对于页面滚动的绝对位置
                const rect = tabContent.getBoundingClientRect();
                const scrollTop = (document.scrollingElement && document.scrollingElement.scrollTop) || window.pageYOffset || 0;
                const relativeY = scrollTop + (evt.clientY - rect.top);
                position = Math.round(relativeY);
            }

            // 弹出输入框获取时间戳
            promptForTimestamp(position);
        }

        // 弹出输入框获取时间戳
        function promptForTimestamp(position) {
            const timestamp = prompt(`点击位置：${position}px\n\n请输入对应的时间戳（秒）:`, '0');
            if (timestamp !== null) {
                const time = parseFloat(timestamp) || 0;
                recordingMode.captures.push({ time, position });
                // 简短提示
                const count = recordingMode.captures.length;
                console.log(`已记录第 ${count} 个时间戳: time=${time}s, position=${position}px`);
                // 可选：在全屏容器顶部显示已记录数量
                updateRecordingStatus(count);
            }
        }

        // 更新录制状态显示
        function updateRecordingStatus(count) {
            // 更新按钮上的计数显示
            const countDisplay = document.getElementById('recordingCount_fs');
            if (countDisplay) {
                countDisplay.textContent = count;
            }
            
            let statusEl = document.getElementById('recordingStatus_fs');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'recordingStatus_fs';
                statusEl.style.position = 'absolute';
                statusEl.style.top = '60px';
                statusEl.style.left = '16px';
                statusEl.style.backgroundColor = '#dbeafe';
                statusEl.style.border = '1px solid #0ea5e9';
                statusEl.style.padding = '8px 12px';
                statusEl.style.borderRadius = '4px';
                statusEl.style.fontSize = '14px';
                statusEl.style.color = '#0369a1';
                statusEl.style.zIndex = '60';
                // 如果在全屏模式，将提示插入全屏容器，否则插入主内容父容器
                try {
                    if (isFullscreen && fullscreenContainer) fullscreenContainer.appendChild(statusEl);
                    else if (tabContentParent) tabContentParent.appendChild(statusEl);
                    else document.body.appendChild(statusEl);
                } catch (e) {
                    document.body.appendChild(statusEl);
                }
            }
            statusEl.textContent = `已记录 ${count} 个时间戳`;
        }

        // 显示录制总结及保存选项
        function showRecordingSummary() {
            if (recordingMode.captures.length === 0) {
                alert('未记录任何时间戳');
                return;
            }

            // 排序
            recordingMode.captures.sort((a, b) => a.time - b.time);
            
            let msg = `已记录 ${recordingMode.captures.length} 个时间戳:\n\n`;
            recordingMode.captures.forEach((c, idx) => {
                msg += `${idx + 1}. time: ${c.time}s, position: ${c.position}px\n`;
            });
            msg += `\n确认保存这些时间戳到配置文件吗？`;

            if (confirm(msg)) {
                saveTimestampsToConfig();
            } else {
                recordingMode.captures = [];
            }
        }

        // 保存时间戳到 tabs-config.json
        async function saveTimestampsToConfig() {
            try {
                if (!currentTab || !currentTabKey) {
                    throw new Error('未找到当前谱子信息');
                }

                // 准备新的配置数据
                const updatedConfig = { ...tabsConfig };
                updatedConfig[currentTabKey].scroll = recordingMode.captures.map(c => ({
                    time: c.time,
                    position: c.position
                }));

                // 调用后端API保存
                const response = await fetch('/api/save-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tabKey: currentTabKey,
                        scroll: updatedConfig[currentTabKey].scroll
                    })
                });

                if (response.ok) {
                    alert('时间戳已成功保存!');
                    // 更新本地 tabsConfig 和 autoScrollState
                    tabsConfig[currentTabKey].scroll = recordingMode.captures;
                    autoScrollState.steps = recordingMode.captures.slice();
                    recordingMode.captures = [];
                } else {
                    const error = await response.json();
                    throw new Error(error.message || '保存失败');
                }
            } catch (error) {
                console.error('保存失败:', error);
                alert(`保存失败: ${error.message}\n\n请尝试以下方案:\n1. 检查后端服务是否运行\n2. 手动复制下列 JSON 更新到 tabs-config.json:\n\n${JSON.stringify({tabKey: currentTabKey, scroll: recordingMode.captures}, null, 2)}`);
            }
        }

        // stop auto-scroll when exiting fullscreen
        function stopAutoScrollOnExit() {
            if (autoScrollState.playing) stopAutoScroll();
        }
        // ========== 全屏逻辑结束 ==========
        // 页面加载后执行
        window.addEventListener('DOMContentLoaded', async () => {
                // 初始化：先禁用按钮，等配置加载完成再启用
                if (autoScrollBtn) {
                    autoScrollBtn.disabled = true;
                    autoScrollBtn.style.opacity = '0.5';
                    autoScrollBtn.style.cursor = 'not-allowed';
                }
                await loadTabConfig(); // 先加载配置
                // 加载图片（异步）
                loadTabImages();      // 再加载图片
                // 配置加载完成后启用自动滚动按钮（即使图片尚未加载完，startAutoScroll 会等待图片）
                if (autoScrollBtn) {
                    autoScrollBtn.disabled = false;
                    autoScrollBtn.style.opacity = '1';
                    autoScrollBtn.style.cursor = 'pointer';
                }
        });
    </script>
</body>
</html>